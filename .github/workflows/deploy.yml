name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and Push Docker Image
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        format: spdx-json
        output-file: sbom.spdx.json
        
    - name: Upload SBOM
      uses: actions/upload-artifact@v3
      with:
        name: sbom
        path: sbom.spdx.json

  # Security Scan of Built Image
  security-scan:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    permissions:
      security-events: write
      
    steps:
    - name: Scan Docker image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment: 
      name: staging
      url: https://staging-api.yourdomain.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'
        
    - name: Set up Kubernetes context
      run: |
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl config current-context
        
    - name: Deploy to staging
      env:
        KUBECONFIG: kubeconfig
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
      run: |
        # Update image in deployment files
        sed -i "s|IMAGE_PLACEHOLDER|$IMAGE_TAG|g" deployment/kubernetes/deployment.yaml
        
        # Apply configurations
        kubectl apply -f deployment/kubernetes/namespace.yaml
        kubectl apply -f deployment/kubernetes/configmap.yaml
        kubectl apply -f deployment/kubernetes/secrets.yaml
        kubectl apply -f deployment/kubernetes/deployment.yaml
        kubectl apply -f deployment/kubernetes/service.yaml
        kubectl apply -f deployment/kubernetes/ingress.yaml
        
        # Wait for rollout
        kubectl rollout status deployment/rag-backend -n rag-system --timeout=600s
        
    - name: Run smoke tests
      run: |
        # Wait for service to be ready
        sleep 30
        
        # Health check
        curl -f https://staging-api.yourdomain.com/health || exit 1
        
        # API test
        curl -f -X POST https://staging-api.yourdomain.com/api/v1/query \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ secrets.API_TEST_TOKEN }}" \
          -d '{"query": "What is machine learning?"}' || exit 1
          
        echo "Staging deployment successful!"

  # Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push, security-scan, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: 
      name: production
      url: https://api.yourdomain.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'
        
    - name: Set up Kubernetes context
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl config current-context
        
    - name: Deploy to production
      env:
        KUBECONFIG: kubeconfig
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
      run: |
        # Update image in deployment files
        sed -i "s|IMAGE_PLACEHOLDER|$IMAGE_TAG|g" deployment/kubernetes/deployment.yaml
        
        # Apply configurations with production settings
        kubectl apply -f deployment/kubernetes/namespace.yaml
        kubectl apply -f deployment/kubernetes/configmap.yaml
        kubectl apply -f deployment/kubernetes/secrets.yaml
        kubectl apply -f deployment/kubernetes/deployment.yaml
        kubectl apply -f deployment/kubernetes/service.yaml
        kubectl apply -f deployment/kubernetes/ingress.yaml
        kubectl apply -f deployment/kubernetes/hpa.yaml
        
        # Rolling update
        kubectl rollout status deployment/rag-backend -n rag-system --timeout=600s
        
    - name: Run production health checks
      run: |
        # Wait for service to be ready
        sleep 60
        
        # Health check
        curl -f https://api.yourdomain.com/health || exit 1
        
        # Metrics check
        curl -f https://api.yourdomain.com/api/v1/monitoring/metrics \
          -H "Authorization: Bearer ${{ secrets.API_TEST_TOKEN }}" || exit 1
          
        echo "Production deployment successful!"
        
    - name: Notify team
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: |
          Production deployment ${{ job.status }}!
          Image: ${{ needs.build-and-push.outputs.image-tag }}
          Commit: ${{ github.sha }}

  # Post-Deployment Monitoring
  post-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success() && (startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'))
    
    steps:
    - name: Monitor deployment
      run: |
        echo "Starting post-deployment monitoring..."
        
        # Monitor for 10 minutes
        for i in {1..20}; do
          # Health check
          if ! curl -f -s https://api.yourdomain.com/health > /dev/null; then
            echo "Health check failed at $(date)"
            exit 1
          fi
          
          echo "Health check $i/20 passed at $(date)"
          sleep 30
        done
        
        echo "Post-deployment monitoring completed successfully"
        
    - name: Create deployment record
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Automated production deployment',
            auto_merge: false,
            required_contexts: []
          });

  # Rollback on Failure
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure()
    environment: production
    
    steps:
    - name: Rollback deployment
      run: |
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        
        # Rollback to previous version
        kubectl rollout undo deployment/rag-backend -n rag-system
        kubectl rollout status deployment/rag-backend -n rag-system --timeout=300s
        
        echo "Rollback completed"
        
    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: 'warning'
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          ðŸš¨ Production deployment failed and was rolled back!
          Please check the logs and fix the issues before retrying.
